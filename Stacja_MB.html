<!doctype html>
<html lang="pl">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Hex-Connect — stabilna</title>
<style>
  :root{
    --bg:#202227;--panel:#2a2d3d;--panel2:#0f1118;--st:#3a3e57;--ink:#e7ebff;--muted:#9fb0ff;
    --accent:#6fc4e4;--ok:#66ff99;--warn:#ffcc66;--bad:#e67878;
  }
  *{box-sizing:border-box}
  body{margin:0;background:var(--bg);color:var(--ink);font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial}
  header{padding:10px 14px;display:flex;gap:10px;align-items:center;background:var(--panel);border-bottom:1px solid var(--st)}
  header .spacer{flex:1}
  button{background:var(--panel2);color:var(--ink);border:1px solid var(--st);border-radius:10px;padding:10px 14px;cursor:pointer}
  button[hidden]{display:none}
  button.primary{border-color:#7aa0ff;box-shadow:0 0 0 1px #7aa0ff33 inset}
  .badge{margin-left:10px;padding:2px 8px;border-radius:999px;background:var(--panel2);color:var(--muted);border:1px solid var(--st);font-weight:700}
  /* Responsywny canvas o stałych proporcjach; heksy skalują się matematycznie */
  canvas{
    display:block;margin:16px auto;background:var(--panel2);
    border:1px solid var(--st);border-radius:16px;max-width:100%;
    width:min(1400px,98vw); aspect-ratio:1100/900; height:auto;
  }
  /* Overlays / modale */
  .overlay{position:fixed;inset:0;background:linear-gradient(180deg,#141621,transparent 30%),radial-gradient(1200px 700px at 50% -200px,#1f2240,transparent 60%),var(--bg);display:flex;align-items:center;justify-content:center;padding:24px;z-index:1000}
  .panel{width:min(900px,95vw);background:var(--panel);border:1px solid var(--st);border-radius:18px;padding:24px;box-shadow:0 10px 40px #0008}
  .row{display:flex;gap:16px;flex-wrap:wrap}
  .row>*{flex:1 1 220px}
  .tile-card{background:var(--panel2);border:1px solid var(--st);border-radius:14px;padding:12px;display:flex;gap:12px;align-items:center}
  .icon{width:44px;height:44px;display:inline-grid;place-items:center;border-radius:10px;border:1px solid var(--st);background:#161824}
  .icon svg{width:28px;height:28px}
  dialog{border:none;border-radius:16px;padding:0;background:transparent}
  dialog::backdrop{background:#000a}
  .modal{background:var(--panel);border:1px solid var(--st);border-radius:16px;padding:20px;max-width:min(900px,95vw);color:#fff}
  .modal footer{display:flex;justify-content:flex-end;margin-top:12px}
  .label{opacity:.8}
  .tile-icon{width:44px;height:44px;border-radius:10px;border:1px solid var(--st);background:#161824;display:flex;justify-content:center;align-items:center}
  .tile-icon canvas{width:36px;height:36px;border:none;background:transparent;margin:0}
</style>
</head>
<body>
<header>
  <button id="btnMenu" class="primary">Menu</button>
  <button id="btnNew">Nowa plansza</button>
  <button id="btnReset">Reset</button>
  <button id="btnNext" hidden>Następny poziom ▶</button>
  <div class="spacer"></div>
  Ruchy: <strong id="moves">0</strong>
  <span class="badge" id="status">—</span>
  Punkty: <strong id="score">0</strong>
</header>

<canvas id="board" width="1100" height="900"></canvas>

<!-- Overlay startowy -->
<div id="startOverlay" class="overlay">
  <div class="panel">
    <h1>Hex-Connect</h1>
    <p>Poprowadź wodę od <strong>startu</strong> do <strong>mety</strong>. Obracaj kafelki, unikaj zalewania pustych pól. Zasil <em>elektrownie wodne</em> i <em>strefy przemysłowe</em> dla bonusów!</p>
    <div class="row" style="margin-top:10px">
      <button id="btnStart" class="primary">Start</button>
      <button id="btnHow">How to play?</button>
    </div>
  </div>
</div>

<!-- How to play -->
<dialog id="howDialog">
  <div class="modal">
    <h2>Jak grać?</h2>
    <div class="row">
      <div class="tile-card">
        <div class="tile-icon">
          <canvas id="iconPipe" width="36" height="36"></canvas>
        </div>
        <div><strong>Kafelek połączeń</strong><div class="label">Kliknij, by obrócić (⇧ Shift = w lewo).</div></div>
      </div>
      <div class="tile-card">
        <div class="tile-icon">
          <canvas id="iconMountain" width="36" height="36"></canvas>
        </div>
        <div><strong>Góra</strong><div class="label">Blokuje przepływ wody.</div></div>
      </div>
      <div class="tile-card">
        <div class="tile-icon">
          <canvas id="iconStart" width="36" height="36"></canvas>
        </div>
        <div><strong>Start</strong><div class="label">Źródło wody.</div></div>
      </div>
      <div class="tile-card">
        <div class="tile-icon">
          <canvas id="iconFinish" width="36" height="36"></canvas>
        </div>
        <div><strong>Meta</strong><div class="label">Doprowadź tu wodę, by wygrać.</div></div>
      </div>
      <div class="tile-card">
        <div class="tile-icon">
          <canvas id="iconHydro" width="36" height="36"></canvas>
        </div>
        <div><strong>Elektrownia</strong><div class="label">Przepuszcza wodę; bonus +150 po zasileniu.</div></div>
      </div>
      <div class="tile-card">
        <div class="tile-icon">
          <canvas id="iconIndustry" width="36" height="36"></canvas>
        </div>
        <div><strong>Przemysł</strong><div class="label">Pełna przepuszczalność; bonus +100.</div></div>
      </div>
      <div class="tile-card">
        <div class="tile-icon">
          <canvas id="iconPickaxe" width="36" height="36"></canvas>
        </div>
        <div><strong>Kopalnia</strong><div class="label">Bonus +50 po zasileniu.</div></div>
      </div>
    </div>
    <footer><button id="btnCloseHow">Zamknij</button></footer>
  </div>
</dialog>

<!-- Wygrana -->
<dialog id="winDialog">
  <div class="modal">
    <h2>Poziom ukończony!</h2>
    <p id="finalStats" class="label">Wynik: 0</p>
    <footer>
      <button id="btnWinClose">OK</button>
      <button id="btnWinNext" class="primary">Następny poziom ▶</button>
    </footer>
  </div>
</dialog>

<script>
(()=> {
  const TAU=Math.PI*2, DPR=window.devicePixelRatio||1;
  const canvas=document.getElementById('board'), ctx=canvas.getContext('2d');
  const statusEl=document.getElementById('status'), scoreEl=document.getElementById('score'), movesEl=document.getElementById('moves'), btnNext=document.getElementById('btnNext');

  const startOverlay=document.getElementById('startOverlay'), howDialog=document.getElementById('howDialog'), winDialog=document.getElementById('winDialog'), finalStats=document.getElementById('finalStats');

  /* -------- Audio -------- */
  let audioCtx;
  function getAudio(){ if(!audioCtx){ const C=window.AudioContext||window.webkitAudioContext; if(C) audioCtx=new C(); } if(audioCtx && audioCtx.state==='suspended') audioCtx.resume(); return audioCtx; }
  function playStone(){ const ac=getAudio(); if(!ac) return; const o=ac.createOscillator(), g=ac.createGain(); o.type='triangle'; o.frequency.setValueAtTime(220,ac.currentTime); o.frequency.exponentialRampToValueAtTime(120,ac.currentTime+0.08); g.gain.setValueAtTime(0.12,ac.currentTime); g.gain.exponentialRampToValueAtTime(0.0001,ac.currentTime+0.12); o.connect(g).connect(ac.destination); o.start(); o.stop(ac.currentTime+0.13); }
  function playSplash(){ const ac=getAudio(); if(!ac) return; const o=ac.createOscillator(), g=ac.createGain(); o.type='sine'; o.frequency.setValueAtTime(150,ac.currentTime); o.frequency.exponentialRampToValueAtTime(80,ac.currentTime+0.3); g.gain.setValueAtTime(0.1,ac.currentTime); g.gain.exponentialRampToValueAtTime(0.0001,ac.currentTime+0.4); o.connect(g).connect(ac.destination); o.start(); o.stop(ac.currentTime+0.4); }
  function playBonus(){ const ac=getAudio(); if(!ac) return; const o=ac.createOscillator(), g=ac.createGain(); o.type='sine'; o.frequency.setValueAtTime(440,ac.currentTime); o.frequency.exponentialRampToValueAtTime(880,ac.currentTime+0.2); g.gain.setValueAtTime(0.1,ac.currentTime); g.gain.exponentialRampToValueAtTime(0.0001,ac.currentTime+0.3); o.connect(g).connect(ac.destination); o.start(); o.stop(ac.currentTime+0.3); }

  /* -------- Hex math + autosize -------- */
  const HEX={
    DIRS:[[1,0],[0,1],[-1,1],[-1,0],[0,-1],[1,-1]],
    toPixel(q,r,s){return {x:s*Math.sqrt(3)*(q+r/2), y:s*1.5*r};},
    corner(cx,cy,s,i){const a=TAU*((i+0.5)/6);return {x:cx+s*Math.cos(a), y:cy+s*Math.sin(a)};},
    mid(cx,cy,s,i){const a=TAU*(i/6), rc=s*Math.cos(Math.PI/6);return {x:cx+rc*Math.cos(a),y:cy+rc*Math.sin(a)};}
  };
  function computeAutoSize(R){
    const pad=16;
    const availW=(canvas.clientWidth||1100)-pad*2;
    const availH=((canvas.clientWidth||1100)*(900/1100))-pad*2;
    const sW=availW/(Math.sqrt(3)*(2*R+1));
    const sH=availH/(1.5*(2*R+1));
    return Math.max(18, Math.floor(Math.min(sW, sH)));
  }

  /* -------- Tiles -------- */
  const TILE={ EMPTY:'empty', PIPE:'pipe', HYDRO:'hydro', INDUSTRY:'industry', MINE:'mine' };
  const ICONS=["mountain","pickaxe"];

  class Tile{
    constructor(q,r,kind,groups=null){
      this.q=q; this.r=r; this.kind=kind; this.icon=null;
      if(kind===TILE.EMPTY){ this.baseGroups=[]; this.icon=ICONS[(Math.random()*ICONS.length)|0]; }
      else if(kind===TILE.HYDRO || kind===TILE.INDUSTRY || kind===TILE.MINE){ this.baseGroups=[[0,1,2,3,4,5]]; }
      else { const norm=(groups||[]).map(g=>g.map(e=>((e%6)+6)%6)); const uniq=Array.from(new Set(norm.flat())).sort((a,b)=>a-b); this.baseGroups=(uniq.length>=3)?[uniq]:norm; }
      this.rot=0; this.isStart=false; this.isFinish=false; this.supplied=false;
      this.penalized = false; // Nowa flaga - czy już naliczono karę
    }
    get empty(){return this.kind===TILE.EMPTY;}
    get groups(){ if(this.empty) return []; return this.baseGroups.map(g=>g.map(e=>(e+this.rot)%6)); }
    get edges(){ if(this.empty) return new Set(); const s=new Set(); for(const g of this.groups) for(const e of g) s.add(e); return s; }
    cw(){ if(this.kind!==TILE.EMPTY) this.rot=(this.rot+1)%6; }
    ccw(){ if(this.kind!==TILE.EMPTY) this.rot=(this.rot+5)%6; }
  }

  /* -------- Board -------- */
  class Board{
    constructor(){
      this.R=7; this.tiles=new Map(); this.size=40; this.origin={x:canvas.width/2,y:canvas.height/2};
      this.startKey=null; this.finishKey=null; this.time=0; this.moves=0; this.score=0; this.t0=0;
      this.speed=0.02; this.tileDist=new Map(); this.phase=0; this.won=false; this.levelSpec=null;
    }
    key(q,r){return q+","+r;}
    set(q,r,t){this.tiles.set(this.key(q,r),t);}
    get(q,r){return this.tiles.get(this.key(q,r));}
    forEach(fn){for(const t of this.tiles.values()) fn(t);}
    neighborInDir(q,r,i){const [dq,dr]=HEX.DIRS[i]; const nt=this.get(q+dq,r+dr); return nt?{q:q+dq,r:r+dr,t:nt,i}:null;}

    randomGroups(){
      const pool=[0,1,2,3,4,5].sort(()=>Math.random()-0.5); const r=Math.random();
      if(r<0.10) return [pool.slice(0,4)];
      if(r<0.25) return [pool.slice(0,3)];
      if(r<0.85) return [[pool[0],pool[1]]];
      return [[pool[0],pool[1]],[pool[2],pool[3]]];
    }

    generate(spec){
      this.levelSpec=spec; this.R=spec.R; this.speed=spec.speed||0.02;
      this.tiles.clear(); this.time=0; this.moves=0; this.score=0; this.t0=0; this.won=false; this.tileDist.clear(); this.phase=0;

      resizeCanvas();
      this.size=computeAutoSize(this.R);

      for(let q=-this.R;q<=this.R;q++){
        for(let r=-this.R;r<=this.R;r++){
          const s=-q-r;
          if(Math.abs(q)<=this.R && Math.abs(r)<=this.R && Math.abs(s)<=this.R){
            let kind=TILE.PIPE, groups=null;
            if(Math.random()<spec.emptyChance) kind=TILE.EMPTY;
            if(kind===TILE.PIPE) groups=this.randomGroups();
            const t=new Tile(q,r,kind,groups);
            if(kind===TILE.PIPE) t.rot=(Math.random()*6)|0;
            this.set(q,r,t);
          }
        }
      }
      // start/meta
      const left=[], right=[];
      this.forEach(t=>{ if(t.q+t.r===-this.R && !t.empty) left.push(t); if(t.q+t.r===this.R && !t.empty) right.push(t); });
      const start=left[(Math.random()*left.length)|0], finish=right[(Math.random()*right.length)|0];
      if(start){ start.isStart=true; this.startKey=this.key(start.q,start.r); }
      if(finish){ finish.isFinish=true; this.finishKey=this.key(finish.q,finish.r); }

      // specjalne - z zapewnieniem minimalnej odległości od pustych pól
      placeSpecialWithDistance(this, TILE.HYDRO, spec.hydroCount|0);
      placeSpecialWithDistance(this, TILE.INDUSTRY, spec.industryCount|0);
      placeSpecialWithDistance(this, TILE.MINE, spec.mineCount|0);

      statusEl.textContent='—'; scoreEl.textContent=this.score; movesEl.textContent=this.moves; btnNext.hidden=true;
    }

    updateDistances(){
      this.tileDist.clear();
      const start=this.tiles.get(this.startKey); if(!start) return;
      const q=[this.startKey]; this.tileDist.set(this.startKey,0);
      while(q.length){
        const k=q.shift(); const [qq,rr]=k.split(',').map(Number); const t=this.get(qq,rr); const d=this.tileDist.get(k);
        if(!t) continue;
        for(const e of t.edges){
          const n=this.neighborInDir(qq,rr,e); if(!n) continue;
          const nk=this.key(n.q,n.r), back=(e+3)%6;
          if(!(n.t.isFinish || n.t.empty || n.t.kind===TILE.HYDRO || n.t.kind===TILE.INDUSTRY || n.t.kind===TILE.MINE) && !n.t.edges.has(back)) continue;
          if(!this.tileDist.has(nk)){ this.tileDist.set(nk,d+1); q.push(nk); }
        }
      }
    }

    draw(){
      // czyść tło DPI-safe
      ctx.save(); ctx.setTransform(1,0,0,1,0,0);
      ctx.clearRect(0,0,canvas.width,canvas.height);
      ctx.fillStyle='#0f1118'; ctx.fillRect(0,0,canvas.width,canvas.height);
      ctx.restore(); ctx.setTransform(DPR,0,0,DPR,0,0);

      this.time+=1; this.phase=(this.time-this.t0)*this.speed; this.updateDistances();

      // rysuj heksy
      this.forEach(t=>{
        const {x,y}=HEX.toPixel(t.q,t.r,this.size); const cx=this.origin.x+x, cy=this.origin.y+y;
        const fill=t.empty?'rgba(230,120,120,0.07)':'rgba(255,255,255,0.03)';
        hexPath(cx,cy,this.size); ctx.lineWidth=2; ctx.strokeStyle='rgba(154,163,199,0.30)'; ctx.fillStyle=fill; ctx.fill(); ctx.stroke();
        if(!t.empty){
          for(const i of t.edges){
            const m=HEX.mid(cx,cy,this.size,i);
            ctx.beginPath(); ctx.moveTo(cx,cy); ctx.lineTo(m.x,m.y);
            ctx.lineWidth=5; ctx.strokeStyle='rgba(154,163,199,0.26)'; ctx.lineCap='round'; ctx.stroke();
          }
        }
        if(t.isStart) ring(cx,cy,this.size*0.33,'#ffcc66');
        if(t.isFinish) ring(cx,cy,this.size*0.33,'#66ff99');
        if(t.empty) drawIcon(t.icon,cx,cy,this.size*0.45);
        if(t.kind===TILE.HYDRO) drawHydro(cx,cy,this.size*0.55);
        if(t.kind===TILE.INDUSTRY) drawGear(cx,cy,this.size*0.5);
        if(t.kind===TILE.MINE) drawMine(cx,cy,this.size*0.5);
      });

      // kary/bonusy
      let penalty=0; 
      this.forEach(tt=>{ 
        const kk=this.key(tt.q,tt.r); 
        if(tt.empty && this.tileDist.has(kk) && !tt.penalized && tt.icon !== "mountain") {
          penalty++; 
          tt.penalized = true; 
        } 
      });
      
      let bonus=0; 
      this.forEach(tt=>{ 
        const kk=this.key(tt.q,tt.r); 
        const d=this.tileDist.get(kk); 
        if(d!==undefined && this.phase>=d && !tt.supplied){ 
          if(tt.kind===TILE.HYDRO){ bonus+=150; tt.supplied=true; playBonus(); } 
          if(tt.kind===TILE.INDUSTRY){ bonus+=100; tt.supplied=true; playBonus(); } 
          if(tt.kind===TILE.MINE){ bonus+=50; tt.supplied=true; playBonus(); } 
        } 
      });
      
      this.score += bonus; 
      this.score += -10 * penalty; 
      scoreEl.textContent=this.score;

      // rozlew z animacją - wolniejsze pulsowanie z poświatą
      const wave = 0.7 + 0.3 * Math.sin(this.time * 0.05); // Wolniejsze pulsowanie
      this.forEach(t=>{
        const k=this.key(t.q,t.r); const dA=this.tileDist.get(k); if(dA===undefined) return;
        const {x,y}=HEX.toPixel(t.q,t.r,this.size); const cx=this.origin.x+x, cy=this.origin.y+y;
        if(this.phase>=dA){
          for(const e of t.edges){
            const nb=this.neighborInDir(t.q,t.r,e); if(!nb) continue;
            const back=(e+3)%6;
            if(!(nb.t.isFinish || nb.t.empty || nb.t.kind===TILE.HYDRO || nb.t.kind===TILE.INDUSTRY || nb.t.kind===TILE.MINE) && !nb.t.edges.has(back)) continue;
            const m=HEX.mid(cx,cy,this.size,e);
            
            // Poświata
            ctx.beginPath(); ctx.moveTo(cx,cy); ctx.lineTo(m.x,m.y);
            ctx.lineWidth=8; ctx.strokeStyle=`rgba(111,196,228,${Math.min(1,(this.phase-dA)) * 0.3})`; ctx.lineCap='round'; ctx.stroke();
            
            // Główna linia wody
            ctx.beginPath(); ctx.moveTo(cx,cy); ctx.lineTo(m.x,m.y);
            ctx.lineWidth=6; ctx.strokeStyle=`rgba(111,196,228,${Math.min(1,(this.phase-dA)) * wave})`; ctx.lineCap='round'; ctx.stroke();
            
            // Odtwórz dźwięk wody tylko raz dla każdego kafelka
            if (this.phase - dA < 0.1 && !t.supplied) {
              playSplash();
            }
          }
        }
      });

      // win
      if(!this.won && this.tileDist.has(this.finishKey)){
        const d=this.tileDist.get(this.finishKey);
        if(this.phase>=d){
          this.won=true; statusEl.textContent='Wygrana!';
          const finalScore=Math.max(0, this.score + 500 - this.moves*2);
          finalStats.textContent=`Wynik: ${finalScore} (ruchy: ${this.moves})`;
          btnNext.hidden=false;
          if(winDialog && winDialog.showModal) winDialog.showModal();
        }
      }
    }
  }

  /* -------- helpers -------- */
  function placeSpecialWithDistance(board, kind, count) {
    const candidates = [];
    const emptyTiles = [];
    
    // Znajdź wszystkie puste pola
    board.forEach(t => {
      if (t.empty) {
        emptyTiles.push(t);
      }
    });

    // Znajdź kandydatów spełniających warunek odległości
    board.forEach(t => {
      if (!t.empty && !t.isStart && !t.isFinish && t.kind === TILE.PIPE) {
        let valid = true;
        
        // Sprawdź odległość od każdego pustego pola
        for (const emptyTile of emptyTiles) {
          const distance = Math.abs(t.q - emptyTile.q) + Math.abs(t.r - emptyTile.r) + Math.abs(t.q + t.r - emptyTile.q - emptyTile.r);
          if (distance <= 2) { // Minimalna odległość 2 heksy
            valid = false;
            break;
          }
        }
        
        if (valid) {
          candidates.push(t);
        }
      }
    });

    for (let i = 0; i < count && candidates.length; i++) {
      const idx = (Math.random() * candidates.length) | 0;
      const base = candidates.splice(idx, 1)[0];
      const spec = new Tile(base.q, base.r, kind);
      spec.rot = 0;
      board.set(base.q, base.r, spec);
    }
  }

  function hexPath(cx,cy,s){ ctx.beginPath(); for(let i=0;i<6;i++){ const p=HEX.corner(cx,cy,s,i); if(i===0) ctx.moveTo(p.x,p.y); else ctx.lineTo(p.x,p.y);} ctx.closePath(); }
  function ring(cx,cy,r,stroke){ ctx.beginPath(); ctx.arc(cx,cy,r,0,TAU); ctx.lineWidth=3; ctx.strokeStyle=stroke; ctx.stroke(); }
  function drawIcon(type,cx,cy,r){
    ctx.save(); ctx.translate(cx,cy); ctx.strokeStyle='rgba(230,120,120,0.9)'; ctx.lineWidth=2; ctx.fillStyle='rgba(230,120,120,0.15)';
    if(type==="mountain"){ 
      drawTriangle(-r*0.6, r*0.35, r*0.8); 
      drawTriangle(0, r*0.4, r*0.9); 
      drawTriangle(r*0.6, r*0.35, r*0.7); 
    }
    else if(type==="pickaxe"){
      // Poprawiony symbol kilofa
      ctx.beginPath();
      // Rękojeść
      ctx.moveTo(-r * 0.3, r * 0.5);
      ctx.lineTo(r * 0.3, -r * 0.5);
      // Głowica kilofa
      ctx.moveTo(-r * 0.2, -r * 0.2);
      ctx.lineTo(r * 0.2, r * 0.2);
      // Ostrze
      ctx.moveTo(r * 0.2, r * 0.2);
      ctx.lineTo(r * 0.4, r * 0.4);
      ctx.moveTo(-r * 0.2, -r * 0.2);
      ctx.lineTo(-r * 0.4, -r * 0.4);
      ctx.stroke();
    }
    ctx.restore();
  }
  function drawTriangle(x,baseY,size){ ctx.beginPath(); ctx.moveTo(x, baseY-size); ctx.lineTo(x-size*0.6, baseY); ctx.lineTo(x+size*0.6, baseY); ctx.closePath(); ctx.stroke(); ctx.fill(); }
  
  function drawHydro(cx,cy,r){
    ctx.save();
    ctx.translate(cx, cy);
    ctx.rotate(Math.PI); // Obróć o 180 stopni

    ctx.lineWidth = 2;
    ctx.strokeStyle = '#6fc4e4';
    ctx.fillStyle = 'rgba(111, 196, 228, 0.2)';
    
    // Kształt kropli (teraz jest odwrócony)
    ctx.beginPath();
    ctx.moveTo(0, -r*0.8);
    ctx.bezierCurveTo(r*0.6, -r*0.8, r*0.9, 0, 0, r*0.9);
    ctx.bezierCurveTo(-r*0.9, 0, -r*0.6, -r*0.8, 0, -r*0.8);
    ctx.fill();
    ctx.stroke();
    
    // Poprawiona błyskawica
    ctx.beginPath();
    ctx.moveTo(0, -r*0.3);
    ctx.lineTo(r*0.2, -r*0.1);
    ctx.lineTo(-r*0.1, r*0.1);
    ctx.lineTo(r*0.1, r*0.3);
    ctx.lineTo(-r*0.15, r*0.2);
    ctx.lineTo(r*0.05, r*0.4);
    ctx.lineTo(-r*0.2, r*0.1);
    ctx.lineTo(0, -r*0.3);
    ctx.fillStyle = '#6fc4e4';
    ctx.fill();
    
    ctx.restore();
  }
  
  function drawMine(cx,cy,r){
    ctx.save();
    ctx.translate(cx, cy);
    ctx.strokeStyle = '#ffcc66';
    ctx.fillStyle = 'rgba(255, 204, 102, 0.15)';
    ctx.lineWidth = 2;
    
    // Wejście do kopalni
    ctx.beginPath();
    ctx.moveTo(-r * 0.5, r * 0.3);
    ctx.lineTo(r * 0.5, r * 0.3);
    ctx.lineTo(r * 0.3, -r * 0.3);
    ctx.lineTo(-r * 0.3, -r * 0.3);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
    
    // Schody
    ctx.beginPath();
    for (let i = 0; i < 4; i++) {
      ctx.moveTo(-r * 0.3 + i * r * 0.2, -r * 0.3 + i * r * 0.15);
      ctx.lineTo(r * 0.3 - i * r * 0.2, -r * 0.3 + i * r * 0.15);
    }
    ctx.stroke();
    
    ctx.restore();
  }
  
  function drawGear(cx,cy,r){
    ctx.save(); ctx.translate(cx,cy); ctx.strokeStyle='#cbd3ff'; ctx.lineWidth=2; ctx.fillStyle='rgba(203,211,255,0.1)';
    const teeth=8, r1=r*0.55, r2=r*0.8; ctx.beginPath();
    for(let i=0;i<teeth*2;i++){ const ang=(i/(teeth*2))*TAU, rr=(i%2===0)?r2:r1; if(i===0) ctx.moveTo(Math.cos(ang)*rr,Math.sin(ang)*rr); else ctx.lineTo(Math.cos(ang)*rr,Math.sin(ang)*rr); }
    ctx.closePath(); ctx.fill(); ctx.stroke(); ctx.beginPath(); ctx.arc(0,0,r*0.28,0,TAU); ctx.stroke(); ctx.restore();
  }
  function pointInHex(px,py,cx,cy,s){ const dx=Math.abs(px-cx)/s, dy=Math.abs(py-cy)/s, a=Math.cos(Math.PI/6), b=Math.sin(Math.PI/6); return dy<=a && a*dx + b*dy <= a*a; }

  /* -------- canvas resize -------- */
  function resizeCanvas(){
    const cssW=canvas.clientWidth||1100, cssH=cssW*(900/1100);
    canvas.width=Math.round(cssW*DPR); canvas.height=Math.round(cssH*DPR);
    ctx.setTransform(DPR,0,0,DPR,0,0);
    board.origin={x:canvas.width/(2*DPR), y:canvas.height/(2*DPR)};
  }
  window.addEventListener('resize', ()=>{ resizeCanvas(); board.size=computeAutoSize(board.R); });

  /* -------- init + loop -------- */
  const board=new Board();
  function loop(){ board.draw(); requestAnimationFrame(loop); }
  loop();

  // klik kafelka (obrót)
  canvas.addEventListener('click', e=>{
    const rect=canvas.getBoundingClientRect();
    const x=(e.clientX-rect.left)*(canvas.width/rect.width)/DPR;
    const y=(e.clientY-rect.top)*(canvas.height/rect.height)/DPR;
    const t=board.pickTileAt ? board.pickTileAt(x,y) : (()=>{ // pickTileAt w Board (poniżej)
      let cand=null, best=Infinity;
      board.forEach(tt=>{ const {x,y}=HEX.toPixel(tt.q,tt.r,board.size); const cx=board.origin.x+x, cy=board.origin.y+y; const d=Math.hypot(x-cx,y-cy); if(d<best){best=d; cand={t:tt,cx,cy};} });
      if(!cand) return null;
      return pointInHex(x,y,cand.cx,cand.cy,board.size*0.98)?cand.t:null;
    })();
    if(!t || t.empty) return;
    if(e.shiftKey) t.ccw(); else t.cw();
    board.moves++; movesEl.textContent=board.moves; playStone();
  });

  // uzupełnij brakującą metodę pickTileAt (na wypadek refactorów)
  if(!Board.prototype.pickTileAt){
    Board.prototype.pickTileAt=function(px,py){
      let candidate=null, bestD=Infinity;
      this.forEach(t=>{
        const {x,y}=HEX.toPixel(t.q,t.r,this.size);
        const cx=this.origin.x+x, cy=this.origin.y+y;
        const d=Math.hypot(px-cx,py-cy); if(d<bestD){ bestD=d; candidate={t,cx,cy}; }
      });
      if(!candidate) return null;
      return pointInHex(px,py,candidate.cx,candidate.cy,this.size*0.98) ? candidate.t : null;
    }
  }

  // Poziomy (size auto)
  let currentLevel=0;
  function startLevel(n){
    currentLevel=n;
    const specs={
      1:{ R:5, speed:0.025, emptyChance:0.08, hydroCount:1, industryCount:0, mineCount:1 },
      2:{ R:7, speed:0.02,  emptyChance:0.22, hydroCount:1, industryCount:2, mineCount:2 },
    };
    const spec=specs[n]||specs[2];
    board.generate(spec);
    board.size=computeAutoSize(board.R);
    statusEl.textContent='Poziom '+n;
    btnNext.hidden=true;
  }

  /* -------- Funkcje menu -------- */
  function showMenu(){ startOverlay.style.display='flex'; }
  function hideMenu(){ startOverlay.style.display='none'; }
  function openHow(){ 
    if(howDialog && howDialog.showModal) howDialog.showModal(); 
    else { howDialog.setAttribute('open',''); howDialog.style.display='block'; } 
    renderHowToPlayIcons();
  }
  function closeHow(){ if(howDialog && howDialog.close) howDialog.close(); else { howDialog.removeAttribute('open'); howDialog.style.display='none'; } }

  // Renderowanie ikon w oknie "How to play"
  function renderHowToPlayIcons() {
    const icons = {
      'iconPipe': (ctx, size) => {
        ctx.strokeStyle = '#9aa3c7';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(-size, 0);
        ctx.lineTo(size, 0);
        ctx.moveTo(0, -size);
        ctx.lineTo(0, size);
        ctx.stroke();
      },
      'iconMountain': (ctx, size) => {
        drawIcon('mountain', 0, 0, size);
      },
      'iconStart': (ctx, size) => {
        ring(0, 0, size, '#ffcc66');
      },
      'iconFinish': (ctx, size) => {
        ring(0, 0, size, '#66ff99');
      },
      'iconHydro': (ctx, size) => {
        drawHydro(0, 0, size);
      },
      'iconIndustry': (ctx, size) => {
        drawGear(0, 0, size);
      },
      'iconPickaxe': (ctx, size) => {
        drawIcon('pickaxe', 0, 0, size);
      }
    };

    for (const [id, drawFunc] of Object.entries(icons)) {
      const canvas = document.getElementById(id);
      if (!canvas) continue;
      const ctx = canvas.getContext('2d');
      const size = 15;
      
      // Clear and center
      ctx.clearRect(0, 0, 36, 36);
      ctx.save();
      ctx.translate(18, 18);
      
      // Draw the icon
      drawFunc(ctx, size);
      
      ctx.restore();
    }
  }

  /* -------- Inicjalizacja interfejsu użytkownika -------- */
  function initUI() {
    // Bindowanie przycisków
    document.getElementById('btnMenu').onclick = showMenu;
    document.getElementById('btnStart').onclick = () => { 
      try{ getAudio(); }catch(e){} 
      hideMenu(); 
      startLevel(1); 
    };
    document.getElementById('btnHow').onclick = openHow;
    document.getElementById('btnCloseHow').onclick = closeHow;
    document.getElementById('btnWinClose').onclick = () => { 
      if(winDialog && winDialog.close) winDialog.close(); 
    };
    document.getElementById('btnWinNext').onclick = () => { 
      if(winDialog && winDialog.close) winDialog.close(); 
      startLevel(currentLevel+1); 
    };
    document.getElementById('btnNew').onclick = () => { 
      if(board.levelSpec) board.generate(board.levelSpec); 
      board.moves=0; movesEl.textContent=0; 
      board.score=0; scoreEl.textContent=0; 
      statusEl.textContent='—'; 
    };
    document.getElementById('btnReset').onclick = () => { 
      board.forEach(t => { if(!t.empty) t.rot=0; }); 
      board.t0=board.time; 
      board.moves=0; movesEl.textContent=0; 
      board.score=0; scoreEl.textContent=0; 
      statusEl.textContent='—'; 
    };
    btnNext.addEventListener('click', () => startLevel(currentLevel+1));
    
    // Renderuj ikony w oknie How to play
    renderHowToPlayIcons();
  }

  // Inicjalizacja UI po załadowaniu DOM
  if (document.readyState === 'complete') {
    initUI();
  } else {
    window.addEventListener('load', initUI);
  }

  // start – pokaż menu
  showMenu();

  // resize on load
  function initialResize(){ resizeCanvas(); board.size=computeAutoSize(board.R); }
  if(document.readyState==='complete') initialResize();
  else window.addEventListener('load', initialResize);
})();
</script>
</body>
</html>